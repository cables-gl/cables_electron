<!DOCTYPE html>
<html lang="en-US">
<head>
    <base href="./dist/ui/">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/>
    <script>
        window.nodeRequire = require;
        delete window.require;
        delete window.exports;
        delete window.module;
    </script>
    <script src="js/talkerapi.js"></script>
    <script src="../public/js/scripts.electron.js"></script>
    <style>
        body {
            background-color: #222;
            color: white;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
    <title>cables</title>
</head>
<body>

<iframe id="editorIframe" style="width:100%;height:100%;border:0;position:absolute;"></iframe>

<script type="module">
    const path = nodeRequire("path");
    const electron = nodeRequire("electron");
    const module = nodeRequire("module");
    window.ipcRenderer = electron.ipcRenderer; // needed to have ipcRenderer in electron_editor.js
    const settings = electron.ipcRenderer.sendSync("settings");

    document.addEventListener('DOMContentLoaded', () => {
        const editorIframe = document.getElementById("editorIframe");
        let src = path.join(settings.uiDistPath, "index.html") + window.location.search;
        if (window.location.hash) {
            src = src + window.location.hash;
        }
        editorIframe.src = src;
        editorIframe.onload = () => {
            const iframeWindow = editorIframe.contentWindow;
            if(iframeWindow && iframeWindow.loadjs)
            {
                iframeWindow.loadjs.ready("cables_core", (depsNotFound) => {
                    const iframeCables = iframeWindow.CABLES;
                    if(!depsNotFound && (iframeCables && iframeCables.Op)) {
                        iframeCables.Op.prototype.require = (moduleName) =>
                        {
                            if(moduleName === "electron") return electron;
                            try
                            {
                                const modulePath = path.join(settings.currentPatchDir, 'node_modules', moduleName);
                                console.info("trying to load", modulePath);
                                return window.nodeRequire(modulePath);
                            } catch (e)
                            {
                                try {
                                    console.info("trying to load native module", moduleName);
                                    return window.nodeRequire(moduleName);
                                }catch (e) {
                                    console.error("failed to load node module \"" + moduleName + "\" do you need to run `npm install`?", e);
                                    return "";
                                }

                            }
                        }
                    }
                });


                iframeWindow.loadjs.ready("cablesuinew", (depsNotFound) => {
                    const iframeCables = iframeWindow.CABLES;
                    if(iframeCables) {
                        const getOpsForFilename = iframeCables.UI.getOpsForFilename;
                        iframeCables.UI.getOpsForFilename = function (filename) {
                            let defaultOps = getOpsForFilename(filename);
                            if(defaultOps.length === 0) {
                                defaultOps.push(iframeCables.UI.DEFAULTOPNAMES.defaultOpJson);
                                const addOpCb = iframeWindow.gui.corePatch().on("onOpAdd", (newOp) => {
                                    const contentPort = newOp.getPortByName("Content", false);
                                    if(contentPort) contentPort.set("String");
                                    iframeWindow.gui.corePatch().off(addOpCb);
                                });
                            }
                            return defaultOps;
                        }
                        iframeCables.CMD.STANDALONE = electronCommands.functions;
                        iframeCables.CMD.commands = iframeCables.CMD.commands.concat(electronCommands.commands);
                        Object.assign(iframeCables.CMD.PATCH, electronCommands.functionOverrides.PATCH);
                        Object.assign(iframeCables.CMD.RENDERER, electronCommands.functionOverrides.RENDERER);

                    }
                });
                window.editorIframe = iframeWindow;
            }
        }

        window.addEventListener("message", (event) => {
            if (event.data && event.data.type === "hashchange") {
                window.location.hash = event.data.data;
            }
        }, false);

        window.addEventListener("hashchange", () => {
            const patchIframe = document.getElementById("editorIframe");
            if (patchIframe) {
                patchIframe.contentWindow.postMessage({"type": "hashchange", "data": window.location.hash}, "*");
            }
        }, false);

        new web.ElectronEditor({
            config: {
                "isTrustedPatch": true,
                "platformClass": "PlatformStandalone",
                "urlCables": "cables://",
                "urlSandbox": "cables://",
                "user": settings.currentUser,
                "usersettings": { "settings": settings.userSettings },
                "isDevEnv": true,
                "env": "dev",
                "patchId": settings.patchId,
                "patchVersion": "",
                "socketcluster": {},
                "remoteClient": false,
                "buildInfo": settings.buildInfo,
                "patchConfig": {
                    "prefixAssetPath": settings.currentPatchDir
                }
            }
        });
    });
</script>
</body>
</html>
