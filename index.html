<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/>
    <script>
        window.nodeRequire = require;
        delete window.require;
        delete window.exports;
        delete window.module;
    </script>
    <script src="ui/js/talkerapi.js"></script>
    <script src="public/js/scripts.standalone.js"></script>
    <style>
        body {
            background-color: #222;
            color: white;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
    <title>cables</title>
</head>
<body>

<iframe id="editorIframe"
        allow="clipboard-read;clipboard-write;geolocation;camera;microphone;midi;usb;serial;xr-spatial-tracking;ambient-light-sensor;"
        allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true"
        style="width:100%;height:100%;border:0px;position:absolute"></iframe>

<script type="module">
    const path = nodeRequire("path");
    const electron = nodeRequire("electron");
    const module = nodeRequire("module");
    window.ipcRenderer = electron.ipcRenderer; // needed to have ipcRenderer ins standalone_editor.js
    const store = electron.ipcRenderer.sendSync("store");

    document.addEventListener('DOMContentLoaded', () => {
        const editorIframe = document.getElementById("editorIframe");
        let src = path.join(store.uiDistPath, "index.html") + window.location.search;
        if (window.location.hash) {
            src = src + window.location.hash;
        }
        editorIframe.src = src;
        editorIframe.onload = () => {
            const iframeWindow = editorIframe.contentWindow;
            if(iframeWindow && iframeWindow.loadjs)
            {
                const iframeCables = iframeWindow.CABLES;
                iframeWindow.loadjs.ready("cables_core", (depsNotFound) => {
                    if(!depsNotFound && (iframeCables && iframeCables.Op)) {
                        iframeCables.Op.prototype.require = (moduleName) =>
                        {
                            if(moduleName === "electron") return electron;
                            try
                            {
                                const modulePath = path.join(store.currentPatchDir, 'node_modules', moduleName);
                                console.log("trying to load", modulePath);
                                return window.nodeRequire(modulePath);
                            } catch (e)
                            {
                                console.error("failed to load node module \"" + moduleName + "\" do you need to run `npm install`?");
                                return "";
                            }
                        }
                    }
                });
                iframeWindow.loadjs.ready("cablesuinew", (depsNotFound) => {
                    iframeCables.CMD.STANDALONE = standaloneCommands.functions;
                    iframeCables.CMD.commands = iframeCables.CMD.commands.concat(standaloneCommands.commands);
                });
            }
        }


        window.addEventListener("message", (event) => {
            if (event.data && event.data.type === "hashchange") {
                window.location.hash = event.data.data;
            }
        }, false);

        window.addEventListener("hashchange", () => {
            const patchIframe = document.getElementById("editorIframe");
            if (patchIframe) {
                patchIframe.contentWindow.postMessage({"type": "hashchange", "data": window.location.hash}, "*");
            }
        }, false);

        new web.StandaloneEditor(
            {
                config: {
                    "urlCables": "cables://",
                    "urlSandbox": "cables://",
                    "user": store.currentUser,
                    "usersettings": { "settings": store.userSettings },
                    "isDevEnv": true,
                    "env": "dev",
                    "patchId": "",
                    "patchVersion": "",
                    "socketcluster": {},
                    "remoteClient": false,
                    "buildInfo": "{}",
                    "patchConfig": {
                        "prefixAssetPath": store.currentPatchDir
                    }
                }
            });
    });
</script>
</body>
</html>
